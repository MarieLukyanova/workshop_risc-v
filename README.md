# Automation tool for checing RISC-V code

## Зависимости


* [Docker](https://docs.docker.com/get-docker/)

## Сборка докер-образа

```
./scripts/build.sh
```

## (Stepik) Генерация условия задания


```
docker run --rm -it  riscvcourse/workshop_risc-v <кодовое_название_задания> --mode init --seed <seed>
```

## (Stepik) Проверка решения

```
docker run --rm -it -v <полный путь>/solution.s:/app/solution.s:ro  riscvcourse/workshop_risc-v <кодовое_название_задания> --mode check --seed <seed>
```

где solution.s - исходный код вашего решния (или файл с корректным ответом)

## Передача аргументов

Первый аргумент является позиционным и определяет задание. От задания зависят остальные аргменты, они задаются через флаги. Можно позвать справку `--help`, чтобы узнать их. Например `lab3_condition --help` выведет аргументы для задания 3. Часть аргументов, таких как `mode` (генерация условия или проверка решения), `seed`, путь до решения и количество тестов являются общими для всех работ. Т.е. флаг `seed` есть во всех реализованных задачах.

## Как добавить новое задание

Библиотека и main автоматически подтягивают новые работы, нужно только их правильно расположить и правильно назвать.
1. Сделать в папке `src/riscv_course` папку по шаблону `lab<N>_<codename>`, где `<N>` -- номер работы, `<codename>` -- кодовое имя. Дальше работа ведётся только в этой папке.
2. Сделать фалй с заданием, например, `lab10_test.py`. В этом файле создать класс `Lab10Test`, который наследуется от `BaseTaskClass`.
3. Какие методы нужно переопределить:
    * `__init__`: добавить своих аргументов, добавить инициализацию внутренних параметров, **добавить в словарь `check_files` вспомогательные файлы для проверки** (формат: ключ -- имя файла, значение -- содержимое файла)
    * `generate_task` -- добавить вызов генерации задания (seed можно получить через `self.seed`) и вернуть строку с текстовым описаннием задания
    * `_generate_tests` -- добавить генерацию тестов. Тесты нужно создавать в виде класса `TestItem` и добавлять из в список тестов `self.tests`
    * `check_sol_prereq` -- можно переопределить проверку текста предоставленного задания (наличие ret, метки solution, ...). Можно оставить базовое
    * `compile` -- если необходимо поменять опции компиляции, то нужно переопределить этот метод и подставить в вызов `_compile_internal` нужные аргументы. **Без острой необходимости** переопределять метод `_compile_internal` не рекомендуется
    * `run_solution` -- аналогично `compile` только для запуска скомпилированного решения
4. Сделать файл с аргументами cli: `lab10_cli.py`. Определить две функции: `add_cli_args_lab<N>` -- принимает парсер от `argparse` и добавляет аргументов и `create_task_lab<N>` -- создаёт объекта класса задания из переданных аргументов cli. В добавлении аргументов **обязательно** выставить функцию обработки как создание задания: `parser.set_defaults(func=create_task_lab<N>)`. Создать парсер `CLIParser`, в котором указать функцию для аргументов и название. **Важно**, чтобы появились общие аргументы (`--seed` и прочие), необходимо вызвать функцию `add_common_cli_args`. **Важно 2**: чтобы одинаково передавать аргументы для базового класса, нужно использовать `**get_common_cli_args(args)` в при создании объекта задания.
5. Сделать файл `__init__.py`, в котором импортировать класс с задание (`Lab10Test`) и объект парсера (`Lab10CLIParser`), чтобы они были сразу доступны на уровне модуля

После этого работа должна автоматически появится в библиотеке и main. Для примера можно смотреть на работы №1 и №3

